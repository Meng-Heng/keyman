/*
 * Keyman is copyright (C) SIL International. MIT License.
 * 
 * Created by Shawn Schantz on 2024-09-09.
 * 
 * This class is responsible for determining the state of the Keyman input method.
 * It is called from the KMInputController (a subclass of IMKInputController), and
 * shares changes in the state of the input method by synchronously posting
 * notifications to NSNotificationCenter.
 */

/**
 * This  class is needed because there are no available APIs or notifications in macOS that
 * an input method can use to determine whether it is currently active. An input method runs
 * in the background as an application but only receives events from text input clients
 * when it is the active input method.
 *
 * Without any simple way to determine whether the input method is active, it is considered
 * to be in an Active state if it has an active text input client that does not immediately get
 * a deactivate method after activating.
 *
 * It is important for state of the input method to be known so that the On-screen keyboard can
 * be appropriately shown or hidden and the low-level event tap can be stopped or started.
 *
 * The state of the input method is mostly determined by the calls that the OS makes to KMInputController.
 * initWithServer is called when a new text input client is being used with Keyman
 * activateServer is called to inform Keyman that the text input client is ready to send events
 * deactivateServer is called when a client stops being used with Keyman
 *
 * Unfortunately, there is no way to distinguish between deactivate messages that result from
 * 1) changing the text input client which is in use or
 * 2) changing from Keyman to a different input method such as a system keyboard
 * Because of this, we must set a timer after a deactivate to see if an activate follows it.
 * If it does not, then we assume that the user has changed input methods and Keyman is inactive.
 *
 * Note that Keyman does not necessarily receive the deactivate before the activate, so
 * that complicates the handling of these events.
 *
 * Additional complexity is encountered when receiving activate messages. After the Keyman input method
 * becomes inactive, it can receive a pair of activate and deactivate messages in rapid succession.
 * These are unexpected and may be generated by clicking on windows or selecting menus and
 * may only be a few milliseconds apart. We want to ignore these false activate messages
 * rather than showing the OSK and enabling the event tap and then immediately hiding and disabling.
 * The false activate messages are detected by using a timer to ensure that when the
 * state is Inactive, we only change to Active if we receive an activate message that is not followed
 * immediately by a deactivate message.
 */

#import "KMInputMethodLifecycle.h"
#import "KMLogs.h"
#import <AppKit/AppKit.h>
#import "KMSettingsRepository.h"

NSString *const kInputMethodActivatedNotification = @"kInputMethodActivatedNotification";
NSString *const kInputMethodDeactivatedNotification = @"kInputMethodDeactivatedNotification";
NSString *const kInputMethodClientChangeNotification = @"kInputMethodClientChangeNotification";

typedef enum {
  Started,
  Active,
  Inactive
} LifecycleState;

@interface KMInputMethodLifecycle()

@property LifecycleState state;
@property NSMutableDictionary *activeTextInputClients;
@end

@implementation KMInputMethodLifecycle
const double inactivityTimeout = 0.5;
const double minimumActiveDuration = 0.5;

+ (KMInputMethodLifecycle *)shared {
  static KMInputMethodLifecycle *shared = nil;
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    shared = [[KMInputMethodLifecycle alloc] init];
  });
  
  return shared;
}

- (instancetype)init {
  self = [super init];
  if (self) {
    _state = Started;
    _activeTextInputClients = [[NSMutableDictionary alloc] initWithCapacity:2];
  }
  return self;
}

/**
 * called from Application Delgate during init
 */
- (void)startLifecycle {
  _state = Started;
}

/**
 * called when IMKInputController receives an activateServer message
 */
- (void)activateClient:(id)client {
  os_log_debug([KMLogs lifecycleLog], "KMInputMethodLifecycle activateClient, client: %{public}@", client);
  @synchronized(_activeTextInputClients) {
    [self addActiveClient:client];
  }

  if (self.state == Started) {
    /**
     * If state is Started, then change clients and activate immediately.
     * When Keyman is just starting, there does not appear to be any chance of receiving
     * a pair of false activate/deactivate messages.
     */
    [self changeClient];
    [self activateInputMethod];
  } else if (self.state == Inactive) {
    /**
     * Before activating the input method, wait and see if we receive an immediate deactivate call.
     * If not, then it is safe to assume that we should change the state to Active.
     */
    os_log_debug([KMLogs lifecycleLog], "before activating the inactive input method, wait for %1.1f seconds and call activateInputMethodIfNoDeactivation", minimumActiveDuration);
    [self performSelector:@selector(activateInputMethodIfNoDeactivation:) withObject:nil afterDelay:minimumActiveDuration];
  } else if (self.state == Active) {
    /**
     * If the input method was already active, then just send a notification to change clients
     */
      [self changeClient];
  }
}

/**
 * called when IMKInputController receives a deactivateServer message
 */
- (void)deactivateClient:(id)client {
  @synchronized(_activeTextInputClients) {
    os_log_debug([KMLogs lifecycleLog], "KMInputMethodLifecycle deactivateClient, client: %{public}@", client);
    [self removeActiveClient: client];
    
    /**
     * If the input method is currently Active, and we removed the last client, wait and see if another client is activated.
     * If not, then it is time to deactivate the input method.
     *
     * If the input method is currently Inactive, then we may be here during the delay before invoking
     * activateInputMethodIfNoDeactivation. In that case there is nothing special to do here, simply removing the
     * client
     */

    if ((self.state == Active) && (self.activeTextInputClients.count == 0)) {
      os_log_debug([KMLogs lifecycleLog], "no text input clients found in activeTextInputClients map; delay for %1.1f seconds and call deactivateInputMethodIfNoClients", inactivityTimeout);
      [self performSelector:@selector(deactivateInputMethodIfNoClients:) withObject:nil afterDelay:inactivityTimeout];
    }
  }
}

/**
 * Executed after a delay: if no deactivation was received, then the input method is now Active
 */
- (void)activateInputMethodIfNoDeactivation:(id)lastClient {
  @synchronized(_activeTextInputClients) {
    if (self.state == Inactive) {
      if (self.activeTextInputClients.count > 0) {
        [self logClients:@"activateInputMethodIfNoDeactivation found an active client, time to activate the input method"];
        [self activateInputMethod];
      } else {
        os_log_debug([KMLogs lifecycleLog], "activateInputMethodIfNoDeactivation found that the active client was removed, do not activate input method");
      }
    }
  }
}

/**
 * Add to the list of active clients. There are usually zero or one clients in the list, but could
 * bet two when we are late receiving a deactivate message.
 */
- (void)addActiveClient:(id)client {
  NSRunningApplication *currentApp = [[NSWorkspace sharedWorkspace] frontmostApplication];
  NSString *clientAppId = [currentApp bundleIdentifier];
  NSString *keyString = [self keyForClient:client];
  os_log_debug([KMLogs lifecycleLog], "  ++adding client application '%{public}@' to activeTextInputClients map, derived key: %{public}@", clientAppId, keyString);
  [self.activeTextInputClients setObject:clientAppId forKey:keyString];
}

/**
 * Create a key string from the hash of the client object to be used for storing in the activeTextInputClients map
 */
- (NSString*) keyForClient:(id)client {
  NSUInteger key = ((NSObject*)client).hash;
  NSString *keyString = [@(key) stringValue];
  return keyString;
}

/**
 * Executed after a delay: if there are still no clients, then deactivate the input method
 */
- (void)deactivateInputMethodIfNoClients:(id)lastClient {
  @synchronized(_activeTextInputClients) {
    if (self.activeTextInputClients.count == 0) {
      if (self.state == Active) {
        os_log_debug([KMLogs lifecycleLog], "deactivateInputMethodIfNoClients found no clients, time to deactivate");
        [self deactivateInputMethod];
      }
    } else {
      [self logClients:@"deactivateInputMethodIfNoClients found a newly activated client, "];
    }
  }
}

/**
 * Remove from the list of active clients.
 */
- (void)removeActiveClient:(id)client {
  NSString *keyString = [self keyForClient:client];
  NSString *clientAppId = [self.activeTextInputClients objectForKey:keyString];
  if (clientAppId) {
    os_log_debug([KMLogs lifecycleLog], "  --removing client application '%{public}@' from activeTextInputClients map, key: %{public}@", clientAppId, keyString);
    [self.activeTextInputClients removeObjectForKey:keyString];
  } else {
    os_log_debug([KMLogs lifecycleLog], "  key %{public}@ not found in activeTextInputClients map", keyString);
  }
}

/**
 * Write the client list to the log.
 */
- (void) logClients: (NSString*)message {
  os_log_debug([KMLogs lifecycleLog], "%{public}@ activeTextInputClients map: %{public}@", message, self.activeTextInputClients.description);
}

/**
 * Change state to Active and send notification.
 */
- (void)activateInputMethod {
  _state = Active;
  [[NSNotificationCenter defaultCenter] postNotificationName:kInputMethodActivatedNotification object:self];
}

/**
 * Change state to Inactive and send notification.
 */
- (void)deactivateInputMethod {
  _state = Inactive;
  [[NSNotificationCenter defaultCenter] postNotificationName:kInputMethodDeactivatedNotification object:self];
}

/**
 * does not change state, just fires notification so that InputController knows to change the event handler
 */
- (void)changeClient {
  [[NSNotificationCenter defaultCenter] postNotificationName:kInputMethodClientChangeNotification object:self];
}

/**
 * returns true if Started or Active
 */
- (BOOL)shouldEnableEventTap {
  return ((self.state == Started) || (self.state == Active));
}

/**
 * returns true if state is  Active and the Settings require us to show the OSK
 */
- (BOOL)shouldShowOskOnActivate {
  return [KMSettingsRepository.shared readShowOskOnActivate]
    && (self.state == Active);
}

@end
